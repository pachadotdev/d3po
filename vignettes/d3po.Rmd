---
title: "Introduction to d3po"
output: rmarkdown::html_vignette
description: >
  Start here if this is your first time using d3po. You'll learn the basic   
  philosophy, and (hopefully) you'll realize it integrates well with the pipe, 
  `%>%`, and the Tidyverse.
vignette: >
  %\VignetteIndexEntry{Introduction to d3po}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = TRUE,
  comment = "#>",
  fig.width = 10,
  fig.height = 5
)
```

The package `d3po` integrates well with `dplyr`. All the examples here use the 
pipe, `%>%`, both to filter/summarise data and create the charts.

These examples are the same as in the documentation but with some extended comments.

# Setup

Let's start by loading packages.

```{r pkgs, message=FALSE, warning=FALSE}
library(dplyr)
library(d3po)
```

# Pokemon dataset

The included dataset, `pokemon`, has a detailed documentation but let's explore the data structure:

```{r}
glimpse(pokemon)
```

# Box and Whiskers

Box plots are useful for visualizing distributions and comparing them across categories.
You can create both vertical and horizontal box plots by switching x and y axes:

## Weight Distribution by Type

```{r box1}
d3po(pokemon, width = 800, height = 600) %>%
  po_box(daes(x = type_1, y = weight, color = color_1)) %>%
  po_title("Weight Distribution by Type")
```

## Height Distribution by Type (Horizontal)

```{r box2}
d3po(pokemon, width = 800, height = 600) %>%
  po_box(daes(x = height, y = type_1, color = color_1)) %>%
  po_title("Height Distribution by Type")
```

## Log-Transformed Distributions

For data with large ranges, log transformations can be useful:

```{r box3}
# Add log-transformed columns
pokemon$log_weight <- log10(pokemon$weight)
pokemon$log_height <- log10(pokemon$height)

d3po(pokemon, width = 800, height = 600) %>%
  po_box(daes(x = type_1, y = log_weight, color = color_1)) %>%
  po_title("Log(Weight) Distribution by Type")
```

```{r box4}
d3po(pokemon, width = 800, height = 600) %>%
  po_box(daes(x = log_height, y = type_1, color = color_1)) %>%
  po_title("Log(Height) Distribution by Type")
```

# Bar

Bar charts can be oriented vertically or horizontally by switching the x and y axes:

## Vertical Bars

```{r bar1}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

d3po(dout, width = 800, height = 600) %>%
  po_bar(daes(x = type, y = count, color = color)) %>%
  po_title("Vertical Bars")
```

## Horizontal Bars

```{r bar2}
d3po(dout, width = 800, height = 600) %>%
  po_bar(daes(x = count, y = type, color = color)) %>%
  po_title("Horizontal Bars")
```

# Treemap

To plot the share of Pokemon by type, we need to indicate the variables for the
size, group, and (optionally) color. You can also specify the tiling method
(squarify, binary, slice, or dice):

```{r}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

d3po(dout, width = 800, height = 600) %>%
  po_treemap(daes(size = count, group = type, color = color, tiling = "squarify")) %>%
  po_title("Share of Pokemon by main type")
```

# Pie / Donut

Use these plots with caution because polar coordinates have major perceptual 
problems. Use with *EXTREME* caution.

You can customize pie charts with innerRadius (0 for full pie) and angles
(startAngle and endAngle). Here are four common variations:

## Pie

A complete pie chart with no inner radius:

```{r}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

d3po(dout, width = 800, height = 600) %>%
  po_pie(daes(size = count, group = type, color = color)) %>%
  po_title("Full Pie")
```

## Donut

A pie with an inner radius creating a "donut hole":

```{r}
d3po(dout, width = 800, height = 600) %>%
  po_pie(daes(size = count, group = type, color = color, innerRadius = 0.4)) %>%
  po_title("Donut")
```

## Half Pie

A semicircular pie chart:

```{r}
d3po(dout, width = 800, height = 600) %>%
  po_pie(daes(
    size = count, group = type, color = color,
    startAngle = -pi / 2, endAngle = pi / 2
  )) %>%
  po_title("Half Pie")
```

## Half Donut

A semicircular donut chart:

```{r}
d3po(dout, width = 800, height = 600) %>%
  po_pie(daes(
    size = count, group = type, color = color,
    innerRadius = 0.4, startAngle = -pi / 2, endAngle = pi / 2
  )) %>%
  po_title("Half Donut")
```

# Line

Line charts are great for showing trends and evolution over continuous variables.
You can plot multiple series by specifying group and color aesthetics:

```{r line1}
dout <- pokemon[pokemon$name %in% c(
  "Squirtle", "Wartortle", "Blastoise",
  "Charmander", "Charmeleon", "Charizard",
  "Pikachu", "Raichu"
), c("height", "weight", "type_1", "color_1")]

colnames(dout) <- c("height", "weight", "type", "color")

d3po(dout, width = 800, height = 600) %>%
  po_line(daes(
    x = height, y = weight, group = type, color = color
  )) %>%
  po_title("Pokemon Evolution: Weight vs Height by Type")
```

# Area

Area charts are similar to line charts but with filled areas. You can also
stack multiple series:

```{r area1}
dout <- pokemon[pokemon$name %in% c(
  "Squirtle", "Wartortle", "Blastoise",
  "Charmander", "Charmeleon", "Charizard",
  "Pikachu", "Raichu"
), c("height", "weight", "type_1", "color_1")]

colnames(dout) <- c("height", "weight", "type", "color")

d3po(dout, width = 800, height = 600) %>%
  po_area(daes(
    x = height, y = weight, group = type, color = color
  ), stack = FALSE) %>%
  po_title("Pokemon Evolution: Weight vs Height by Type (Area)")
```

# Scatterplot

Scatter plots show the relationship between two continuous variables. You can also
control point size to represent a third dimension:

## Height vs Weight

```{r scatter1}
d3po(pokemon, width = 800, height = 600) %>%
  po_scatter(daes(
    x = height, y = weight, group = name, color = color_1
  )) %>%
  po_title("Height vs Weight")
```

## Log(Height) vs Log(Weight)

```{r scatter2}
# Add log-transformed columns if not already present
if (!"log_height" %in% names(pokemon)) {
  pokemon$log_height <- log10(pokemon$height)
  pokemon$log_weight <- log10(pokemon$weight)
}

d3po(pokemon, width = 800, height = 600) %>%
  po_scatter(daes(
    x = log_height, y = log_weight, group = name, color = color_1
  )) %>%
  po_title("Log(Height) vs Log(Weight)")
```

## With Size Encoding

You can use point size to show how close each Pokemon is to the mean:

```{r scatter3}
# Calculate inverse distance from mean (closer = larger circles)
mean_weight <- mean(pokemon$weight, na.rm = TRUE)
mean_height <- mean(pokemon$height, na.rm = TRUE)

pokemon$distance_from_mean_weight <- abs(pokemon$weight - mean_weight)
pokemon$distance_from_mean_height <- abs(pokemon$height - mean_height)
pokemon$avg_distance <- (pokemon$distance_from_mean_weight + pokemon$distance_from_mean_height) / 2
pokemon$inverse_distance_from_mean <- 1 / (pokemon$avg_distance + 0.01)

d3po(pokemon, width = 800, height = 600) %>%
  po_scatter(daes(
    x = height, y = weight, size = inverse_distance_from_mean,
    group = name, color = color_1
  )) %>%
  po_title("Height vs Weight (Size = 1 / Distance from the Mean)")
```

```{r scatter4}
d3po(pokemon, width = 800, height = 600) %>%
  po_scatter(daes(
    x = log_height, y = log_weight, size = inverse_distance_from_mean,
    group = name, color = color_1
  )) %>%
  po_title("Log(Height) vs Log(Weight) (Size = 1 / Distance from the Mean)")
```

# Geomap

Geographic maps allow you to visualize data across regions. You need to specify
a TopoJSON map and data with matching region IDs:

```{r}
# Get country IDs and names from the South America map
dout <- map_ids(d3po::maps$south_america$continent)

# Chile has Mewtwo and Guyana has Mew
dout$pokemon_count <- ifelse(dout$id == "CL", 1L, 0L)
dout$pokemon_count <- ifelse(dout$id == "GY", 1L, 0L)
dout$color <- ifelse(dout$id %in% c("CL", "GY"), "#F85888", "#e0e0e0")

d3po(dout, width = 800, height = 600) %>%
  po_geomap(
    daes(
      group = id, color = color, size = pokemon_count,
      tooltip = name
    ),
    map = d3po::maps$south_america$continent
  ) %>%
  po_title("Pokemon Distribution in South America")
```

```{r}
# Get region IDs and names from the Chile map
dout <- map_ids(d3po::maps$south_america$chile)

# Only Magallanes has Pokemon (Mewtwo lives there!)
dout$pokemon_count <- ifelse(dout$id == "MA", 1L, 0L)
dout$color <- ifelse(dout$id == "MA", "#F85888", "#e0e0e0")

d3po(dout, width = 800, height = 600) %>%
  po_geomap(
    daes(
      group = id, color = color, size = pokemon_count,
      tooltip = name
    ),
    map = d3po::maps$south_america$chile
  ) %>%
  po_title("Pokemon Distribution in Chile")
```

# Network

Network graphs show relationships between entities. The `pokemon_network` dataset
contains nodes (Pokemon types) and links (connections between type_1 and type_2).
Node size represents the count of each type.

By default, nodes are fixed in their positions. You can enable dragging with `move = TRUE`:

```{r}
# Using KK layout algorithm
d3po(pokemon_network, width = 800, height = 600) %>%
  po_network(daes(size = node_size, color = color, layout = "kk")) %>%
  po_title("Pokemon Type Network (Fixed Positions)")
```

```{r}
# Using FR layout algorithm
d3po(pokemon_network, width = 800, height = 600) %>%
  po_network(daes(size = node_size, color = color, layout = "fr")) %>%
  po_title("Pokemon Type Network (Draggable - nodes stay where you put them)")
```

```{r}
# Use manual positions (from pokemon_network$layout)
d3po(pokemon_network, width = 800, height = 600) %>%
  po_network(daes(size = node_size, color = color)) %>%
  po_title("Pokemon Type Network (Manual Positions)")
```

Here is how I created the `pokemon_network` dataset:

```{r, eval = FALSE}
load_all()
library(dplyr)
library(igraph)

pokemon_network_1 <- pokemon %>%
  filter(!is.na(type_2)) %>%
  group_by(type_1, type_2) %>%
  summarise(edge_size = n(), .groups = "drop") %>%
  rename(
    from = type_1,
    to = type_2
  )

# Create vertices WITH x/y coordinates
pokemon_network_2 <- pokemon %>%
  group_by(type = type_1, color = color_1) %>%
  summarise(node_size = n(), .groups = "drop") %>%
  bind_rows(
    pokemon %>%
      group_by(type = type_2, color = color_2) %>%
      summarise(node_size = n(), .groups = "drop")
  ) %>%
  filter(!is.na(type)) %>%
  group_by(type, color) %>%
  summarise(node_size = sum(node_size), .groups = "drop")

# Create a single network object with manual coordinates
pokemon_network <- igraph::graph_from_data_frame(
  d = pokemon_network_1,
  vertices = pokemon_network_2,
  directed = FALSE
)

pokemon_network$layout <- igraph::layout_with_kk(pokemon_network)
rownames(pokemon_network$layout) <- V(pokemon_network)$name
colnames(pokemon_network$layout) <- c("x", "y")

# Manually optimize layout to minimize edge crossings
# Place Flying at center since it's the biggest hub
pokemon_network$layout["Flying", ] <- c(0, 0)

# Place types that connect to Flying in a circle around it
# Top: Dragon, Electric, Fire
pokemon_network$layout["Dragon", ] <- c(2, 1.5)
pokemon_network$layout["Electric", ] <- c(1, 2)
pokemon_network$layout["Fire", ] <- c(-1, 2)

# Right side: Steel (connects to Electric), Rock, Ground cluster
pokemon_network$layout["Steel", ] <- c(2, 2.2)
pokemon_network$layout["Rock", ] <- c(1.5, -1)
pokemon_network$layout["Ground", ] <- c(0.5, -2)

# Bottom: Ice (connects to Flying, Water, Psychic)
pokemon_network$layout["Ice", ] <- c(-1, -2)
pokemon_network$layout["Water", ] <- c(-2, -1)

# Left side: Poison cluster (connects to Bug, Ghost, Grass, Flying, Ground, Water)
pokemon_network$layout["Poison", ] <- c(-2, 0)
pokemon_network$layout["Bug", ] <- c(-2.4, 1)
pokemon_network$layout["Grass", ] <- c(-3, 0)
pokemon_network$layout["Ghost", ] <- c(-2.5, -0.9)

# Top left: Normal, Fairy (Normal connects to Flying and Fairy)
pokemon_network$layout["Normal", ] <- c(-1.5, 1.5)
pokemon_network$layout["Fairy", ] <- c(-2.5, 2)

# Left side: Psychic (connects to Grass, Ice, Water, Fairy)
pokemon_network$layout["Psychic", ] <- c(-3, -1.5)

# Near Water: Fighting (only connects to Water)
pokemon_network$layout["Fighting", ] <- c(-1.5, -1.5)
```

# Aesthetics

Going back to the treemap example, it is possible to move the labels,
change the background, and also use any font that you like:

```{r}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

d3po(dout, width = 800, height = 600) %>%
  po_treemap(daes(size = count, group = type, color = color)) %>%
  po_title("Share of Pokemon by main type") %>%
  po_labels("center-middle") %>% # default is "left-top"
  po_background("#ffcc00") %>%
  po_font("Comic Sans MS", 16, "uppercase") %>%
  po_download(FALSE) # default is TRUE
```
