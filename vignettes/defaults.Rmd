---
title: "Using D3po with Default Settings"
output: rmarkdown::html_vignette
description: >
  Start here if this is your first time using d3po. You'll learn the basic   
  philosophy, and (hopefully) you'll realize it integrates well with the pipe, 
  `%>%`, and the Tidyverse.
vignette: >
  %\VignetteIndexEntry{Using D3po with Default Settings}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = TRUE,
  comment = "#>",
  fig.width = 10,
  fig.height = 5
)
```

The package `d3po` integrates well with `dplyr`. All the examples here use the 
pipe, `%>%`, both to filter/summarise data and create the charts.

These examples are the same as in the documentation but with some extended comments.

All the data transformations are done using base R to keep the package dependencies minimal. The `dplyr` code
is shown commented out for reference.

# Setup

Let's start by loading packages.

```{r pkgs, message=FALSE, warning=FALSE}
library(d3po)
```

# Pokemon dataset

The included dataset, `pokemon`, has a detailed documentation but let's explore the data structure:

```{r data}
str(pokemon)
```

# Box and Whiskers

Box plots are useful for visualizing distributions and comparing them across categories.
You can create both vertical and horizontal box plots by switching x and y axes:

## Weight Distribution by Type

```{r box1}
d3po(pokemon, width = 800, height = 600) %>%
  po_box(daes(x = type_1, y = weight, color = color_1)) %>%
  po_labels(title = "Weight Distribution by Type")
```

## Height Distribution by Type (Horizontal)

```{r box2}
d3po(pokemon, width = 800, height = 600) %>%
  po_box(daes(x = height, y = type_1, color = color_1)) %>%
  po_labels(title = "Height Distribution by Type")
```

## Log-Transformed Distributions

For data with large ranges, log transformations can be useful:

```{r box3}
dout <- pokemon
dout$log_weight <- log10(dout$weight)
dout$log_height <- log10(dout$height)

# With dplyr
# dout <- pokemon %>%
#   mutate(
#     log_weight = log10(weight),
#     log_height = log10(height)
#   )

d3po(dout, width = 800, height = 600) %>%
  po_box(daes(x = type_1, y = log_weight, color = color_1)) %>%
  po_labels(title = "Log(Weight) Distribution by Type")
```

```{r box4}
dout <- pokemon
dout$log_weight <- log10(dout$weight)
dout$log_height <- log10(dout$height)

# With dplyr
# dout <- pokemon %>%
#   mutate(
#     log_weight = log10(weight),
#     log_height = log10(height)
#   )

d3po(dout, width = 800, height = 600) %>%
  po_box(daes(x = log_height, y = type_1, color = color_1)) %>%
  po_labels(title = "Log(Height) Distribution by Type")
```

# Bar

Bar charts can be oriented vertically or horizontally by switching the x and y axes:

## Vertical Bars

```{r bar1}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_bar(daes(x = type, y = count, color = color)) %>%
  po_labels(title = "Vertical Bars")
```

## Horizontal Bars

```{r bar2}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_bar(daes(x = count, y = type, color = color)) %>%
  po_labels(title = "Horizontal Bars")
```

## Stacked Vertical Bars 

```{r bar3}
dout <- aggregate(cbind(mean_attack = attack, mean_defense = defense) ~ type_1 + color_1,
  data = pokemon, FUN = mean
)

dout <- reshape(dout,
  varying = c("mean_attack", "mean_defense"),
  v.names = "mean",
  timevar = "feature",
  times = c("attack", "defense"),
  direction = "long",
  idvar = c("type_1", "color_1")
)

rownames(dout) <- NULL
colnames(dout) <- c("type", "color", "feature", "mean")

# Represent attach/defense as att = att / (att + def), def = def / (att + def)
# Group by pokemon type for the value proportions
dout$mean <- with(dout, ave(mean, type, FUN = function(x) x / sum(x)))
dout$color <- ifelse(dout$feature == "attack", "#d04e66", "#165976")

# With dplyr and tidyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(
#     mean_attack = mean(attack, na.rm = TRUE),
#     mean_defense = mean(defense, na.rm = TRUE),
#     .groups = "drop"
#   ) %>%
#   pivot_longer(
#     cols = c(mean_attack, mean_defense),
#     names_to = "feature",
#     values_to = "mean"
#   ) %>%
#   mutate(
#     mean = mean / sum(mean),
#     color = ifelse(feature == "mean_attack", "#d04e66", "#165976")
#   )

d3po(dout, width = 800, height = 600) %>%
  po_bar(daes(x = type, y = mean, group = feature, color = color, stack = T)) %>%
  po_labels(title = "Vertical Bars")
```

## Stacked Horizontal Bars 

```{r bar4}
dout <- aggregate(cbind(mean_attack = attack, mean_defense = defense) ~ type_1 + color_1,
  data = pokemon, FUN = mean
)

dout <- reshape(dout,
  varying = c("mean_attack", "mean_defense"),
  v.names = "mean",
  timevar = "feature",
  times = c("attack", "defense"),
  direction = "long",
  idvar = c("type_1", "color_1")
)

rownames(dout) <- NULL
colnames(dout) <- c("type", "color", "feature", "mean")

# Represent attach/defense as att = att / (att + def), def = def / (att + def)
# Group by pokemon type for the value proportions
dout$mean <- with(dout, ave(mean, type, FUN = function(x) x / sum(x)))
dout$color <- ifelse(dout$feature == "attack", "#d04e66", "#165976")

# With dplyr and tidyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(
#     mean_attack = mean(attack, na.rm = TRUE),
#     mean_defense = mean(defense, na.rm = TRUE),
#     .groups = "drop"
#   ) %>%
#   pivot_longer(
#     cols = c(mean_attack, mean_defense),
#     names_to = "feature",
#     values_to = "mean"
#   ) %>%
#   mutate(
#     mean = mean / sum(mean),
#     color = ifelse(feature == "mean_attack", "#d04e66", "#165976")
#   )

d3po(dout, width = 800, height = 600) %>%
  po_bar(daes(y = type, x = mean, group = feature, color = color, stack = T)) %>%
  po_labels(title = "Vertical Bars")
```

# Treemap

To plot the share of Pokemon by type, we need to indicate the variables for the
size, group, and (optionally) color. You can also specify the tiling method
(squarify, binary, slice, or dice):

```{r treemap1}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_treemap(daes(size = count, group = type, color = color, tiling = "squarify")) %>%
  po_labels(title = "Share of Pokemon by main type")
```

# Two-level Treemap

You can also build a two-level treemap by specifying a `subgroup` aesthetic. This
lets you click a top-level type to drill into its second-level types, and click the
background to go back:

```{r treemap2}
type2tmp <- as.character(pokemon$type_2)
type2tmp[is.na(type2tmp)] <- "only"

dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + type2tmp + color_1,
  data = pokemon, FUN = length
)
names(dout) <- c("type1", "type2", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   mutate(
#     type2 = ifelse(is.na(type_2), "only", as.character(type_2))
#   ) %>%
#   group_by(type1 = type_1, type2 = type2, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_treemap(
    daes(
      size = count, group = type1, subgroup = type2, color = color, tiling = "squarify"
    )
  ) %>%
  po_labels(title = "Two-level Treemap by Type 1 and Type 2 (click to drill in/out)")
```

# Pie / Donut

Use these plots with caution because polar coordinates have major perceptual 
problems. Use with *EXTREME* caution.

You can customize pie charts with innerRadius (0 for full pie) and angles
(startAngle and endAngle). Here are four common variations:

## Pie

A complete pie chart with no inner radius:

```{r pie1}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_pie(daes(size = count, group = type, color = color)) %>%
  po_labels(title = "Full Pie")
```

## Donut

A pie with an inner radius creating a "donut hole":

```{r pie2}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_pie(daes(size = count, group = type, color = color, innerRadius = 0.4)) %>%
  po_labels(title = "Donut")
```

## Half Pie

A semicircular pie chart:

```{r pie3}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_pie(
    daes(
      size = count, group = type, color = color, startAngle = -pi / 2, endAngle = pi / 2
    )
  ) %>%
  po_labels(title = "Half Pie")
```

## Half Donut

A semicircular donut chart:

```{r pie4}
dout <- aggregate(cbind(count = rep(1, nrow(pokemon))) ~ type_1 + color_1, data = pokemon, FUN = length)
names(dout) <- c("type", "color", "count")

# With dplyr
# dout <- pokemon %>%
#   group_by(type = type_1, color = color_1) %>%
#   summarise(count = n(), .groups = "drop")

d3po(dout, width = 800, height = 600) %>%
  po_pie(
    daes(
      size = count, group = type, color = color, innerRadius = 0.4, startAngle = -pi / 2, endAngle = pi / 2
    )
  ) %>%
  po_labels(title = "Half Donut")
```

# Line

Line charts are great for showing trends and evolution over continuous variables.
You can plot multiple series by specifying group and color aesthetics:

```{r line1}
dout <- pokemon[pokemon$name %in% c(
  "Squirtle", "Wartortle", "Blastoise",
  "Charmander", "Charmeleon", "Charizard",
  "Pikachu", "Raichu"
), c("height", "weight", "type_1", "color_1")]

colnames(dout) <- c("height", "weight", "type", "color")

# With dplyt
# dout <- pokemon %>%
#   filter(name %in% c(
#     "Squirtle", "Wartortle", "Blastoise",
#     "Charmander", "Charmeleon", "Charizard",
#     "Pikachu", "Raichu"
#   )) %>%
#   select(height, weight, type = type_1, color = color_1)

d3po(dout, width = 800, height = 600) %>%
  po_line(
    daes(
      x = height, y = weight, group = type, color = color
    )
  ) %>%
  po_labels(title = "Pokemon Evolution: Weight vs Height by Type")
```

# Area

## Non-stacked

Area charts are similar to line charts but with filled areas. You can also
stack multiple series:

```{r area1}
dout <- pokemon[pokemon$name %in% c(
  "Squirtle", "Wartortle", "Blastoise"
), c("height", "weight", "type_1", "color_1")]

colnames(dout) <- c("height", "weight", "type", "color")

# With dplyr
# dout <- pokemon %>%
#   filter(name %in% c(
#     "Squirtle", "Wartortle", "Blastoise",
#     "Charmander", "Charmeleon", "Charizard",
#     "Pikachu", "Raichu"
#   )) %>%
#   select(height, weight, type = type_1, color = color_1)

d3po(dout, width = 800, height = 600) %>%
  po_area(
    daes(
      x = height, y = weight, group = type, color = color
    )
  ) %>%
  po_labels(title = "Pokemon Evolution (Squirtle): Weight vs Height by Evolution Stage (Non-Stacked Area)")
```

## Stacked

```{r area2}
load_all()

dout <- pokemon[pokemon$name %in% c(
  "Squirtle", "Wartortle", "Blastoise"
), c("name", "attack", "defense", "hp")]

colnames(dout) <- c("name", "attack", "defense")

dout$stage <- 1:3

# Prepare data in long format for attack and defense
dout <- reshape(
  dout,
  varying = c("attack", "defense"),
  v.names = "value",
  timevar = "feature",
  times = c("attack", "defense"),
  direction = "long",
  idvar = c("name", "stage")
)

dout$color <- ifelse(dout$feature == "attack", "#d04e66", "#165976")

# Group by name and express the value as a proportion of the total (attack + defense)
dout$value <- with(dout, ave(value, name, FUN = function(x) x / sum(x)))

# With dplyr
# dout <- pokemon %>%
#   filter(name %in% c(
#     "Squirtle", "Wartortle", "Blastoise"
#   )) %>%
#   select(name, attack, defense, type = type_1) %>%
#   mutate(stage = 1:3) %>%
#   pivot_longer(
#     cols = c(attack, defense),
#     names_to = "feature"
#     values_to = "value"
#   ) %>%
#   mutate(color = ifelse(feature == "attack", "#d04e66", "#165976")) %>%
#   group_by(name) %>%
#   mutate(value = value / sum(value)) %>%
#   ungroup()

d3po(dout, width = 800, height = 600) %>%
  po_area(
    daes(
      x = stage, y = value, group = feature, color = color, stack = T
    )
  ) %>%
  po_labels(title = "Pokemon Evolution (Squirtle): Defense/Attack Proportion by Evolution Stage (Stacked Area)")
```

# Scatterplot

Scatter plots show the relationship between two continuous variables. You can also
control point size to represent a third dimension:

## Height vs Weight

```{r scatter1}
d3po(pokemon, width = 800, height = 600) %>%
  po_scatter(
    daes(
      x = height, y = weight, group = name, color = color_1
    )
  ) %>%
  po_labels(title = "Height vs Weight")
```

## Log(Height) vs Log(Weight)

```{r scatter2}
dout <- pokemon
dout$log_height <- log10(pokemon$height)
dout$log_weight <- log10(pokemon$weight)

# With dplyr
# dout <- pokemon %>%
#   mutate(
#     log_height = log10(height),
#     log_weight = log10(weight)
#   )

d3po(dout, width = 800, height = 600) %>%
  po_scatter(
    daes(
      x = log_height, y = log_weight, group = name, color = color_1
    )
  ) %>%
  po_labels(title = "Log(Height) vs Log(Weight)")
```

## With Size Encoding

You can use point size to show how close each Pokemon is to the mean:

```{r scatter3}
# Calculate inverse distance from mean (closer = larger circles)
dout <- pokemon
mean_weight <- mean(dout$weight, na.rm = TRUE)
mean_height <- mean(dout$height, na.rm = TRUE)

dout$distance_from_mean_weight <- abs(dout$weight - mean_weight)
dout$distance_from_mean_height <- abs(dout$height - mean_height)
dout$avg_distance <- (dout$distance_from_mean_weight + dout$distance_from_mean_height) / 2
dout$inverse_distance_from_mean <- 1 / (dout$avg_distance + 0.01)

# With dplyr
# dout <- pokemon %>%
#   mutate(
#     distance_from_mean_weight = abs(weight - mean(weight, na.rm = TRUE)),
#     distance_from_mean_height = abs(height - mean(height, na.rm = TRUE)),
#     avg_distance = (distance_from_mean_weight + distance_from_mean_height) / 2,
#     inverse_distance_from_mean = 1 / (avg_distance + 0.01)
#   )

d3po(dout, width = 800, height = 600) %>%
  po_scatter(
    daes(
      x = height, y = weight, size = inverse_distance_from_mean,
      group = name, color = color_1
    )
  ) %>%
  po_labels(title = "Height vs Weight (Size = 1 / Distance from the Mean)")
```

```{r scatter4}
# Calculate inverse distance from mean (closer = larger circles)
dout <- pokemon
dout$log_height <- log10(pokemon$height)
dout$log_weight <- log10(pokemon$weight)
mean_log_weight <- mean(dout$log_weight, na.rm = TRUE)
mean_log_height <- mean(dout$log_height, na.rm = TRUE)

dout$distance_from_mean_log_weight <- abs(dout$log_weight - mean_log_weight)
dout$distance_from_mean_log_height <- abs(dout$log_height - mean_log_height)
dout$avg_distance <- (dout$distance_from_mean_log_weight + dout$distance_from_mean_log_height) / 2
dout$inverse_distance_from_mean <- 1 / (dout$avg_distance + 0.01)

# With dplyr
# dout <- pokemon %>%
#   mutate(
#     log_height = log10(height),
#     log_weight = log10(weight)
#   ) %>%
#   mutate(
#     distance_from_mean_log_weight = abs(log_weight - mean(log_weight, na.rm = TRUE)),
#     distance_from_mean_log_height = abs(log_height - mean(log_height, na.rm = TRUE)),
#     avg_distance = (distance_from_mean_log_weight + distance_from_mean_log_height) / 2,
#     inverse_distance_from_mean = 1 / (avg_distance + 0.01)
#   )

d3po(dout, width = 800, height = 600) %>%
  po_scatter(
    daes(
      x = log_height, y = log_weight, size = inverse_distance_from_mean,
      group = name, color = color_1
    )
  ) %>%
  po_labels(title = "Log(Height) vs Log(Weight) (Size = 1 / Distance from the Mean)")
```

# Geomap

Geographic maps allow you to visualize data across regions. You need to specify
a TopoJSON map and data with matching region IDs:

```{r geomap1}
# Get country IDs and names from the South America map
dout <- map_ids(d3po::maps$south_america$continent)

# Chile has Mewtwo and Guyana has Mew
dout$pokemon_count <- ifelse(dout$id == "CL", 1L, 0L)
dout$pokemon_count <- ifelse(dout$id == "GY", 1L, dout$pokemon_count)
dout$color <- ifelse(dout$id %in% c("CL", "GY"), "#F85888", "#e0e0e0")

# With dplyr
# dout <- map_ids(d3po::maps$south_america$continent) %>%
#   mutate(
#     pokemon_count = case_when(
#       id == "CL" ~ 1L,
#       id == "GY" ~ 1L,
#       TRUE ~ 0L
#     ),
#     color = ifelse(id %in% c("CL", "GY"), "#F85888", "#e0e0e0")
#   )

d3po(dout, width = 800, height = 600) %>%
  po_geomap(
    daes(
      group = id, color = color, size = pokemon_count,
      tooltip = name
    ),
    map = d3po::maps$south_america$continent
  ) %>%
  po_labels(title = "Pokemon Distribution in South America")
```

```{r geomap2}
# Get region IDs and names from the Chile map
dout <- map_ids(d3po::maps$south_america$chile)

# Only Magallanes has Pokemon (Mewtwo lives there!)
dout$pokemon_count <- ifelse(dout$id == "MA", 1L, 0L)
dout$color <- ifelse(dout$id == "MA", "#F85888", "#e0e0e0")

# With dplyr
# dout <- map_ids(d3po::maps$south_america$chile) %>%
#   mutate(
#     pokemon_count = ifelse(id == "MA", 1L, 0L),
#     color = ifelse(id == "MA", "#F85888", "#e0e0e0")
#   )

d3po(dout, width = 800, height = 600) %>%
  po_geomap(
    daes(
      group = id, color = color, size = pokemon_count,
      tooltip = name
    ),
    map = d3po::maps$south_america$chile
  ) %>%
  po_labels(title = "Pokemon Distribution in Chile")
```

# Network

Network graphs show relationships between entities. The `pokemon_network` dataset
contains nodes (Pokemon types) and links (connections between type_1 and type_2).
Node size represents the count of each type.

By default, nodes are fixed in their positions. You can enable dragging with `move = TRUE`:

```{r network1}
# Using KK layout algorithm
d3po(pokemon_network, width = 800, height = 600) %>%
  po_network(daes(size = node_size, color = color, layout = "kk")) %>%
  po_labels(title = "Pokemon Type Network (KK Layout)")
```

```{r network2}
# Using FR layout algorithm
d3po(pokemon_network, width = 800, height = 600) %>%
  po_network(daes(size = node_size, color = color, layout = "fr")) %>%
  po_labels(title = "Pokemon Type Network (FR Layout)")
```

```{r network3}
# Use manual positions (from pokemon_network$layout)
d3po(pokemon_network, width = 800, height = 600) %>%
  po_network(daes(size = node_size, color = color)) %>%
  po_labels(title = "Pokemon Type Network (Manual Positions)")
```

Here is how I created the `pokemon_network` dataset:

```{r network-create, eval = FALSE}
library(dplyr)
library(igraph)
library(jsonlite)
library(purrr)

pokemon_network_1 <- pokemon %>%
  filter(!is.na(type_2)) %>%
  group_by(type_1, type_2) %>%
  summarise(edge_size = n(), .groups = "drop") %>%
  rename(
    from = type_1,
    to = type_2
  )

# Create vertices WITH x/y coordinates
pokemon_network_2 <- pokemon %>%
  group_by(type = type_1, color = color_1) %>%
  summarise(node_size = n(), .groups = "drop") %>%
  bind_rows(
    pokemon %>%
      group_by(type = type_2, color = color_2) %>%
      summarise(node_size = n(), .groups = "drop")
  ) %>%
  filter(!is.na(type)) %>%
  group_by(type, color) %>%
  summarise(node_size = sum(node_size), .groups = "drop")

# Create a single network object with manual coordinates
pokemon_network <- igraph::graph_from_data_frame(
  d = pokemon_network_1,
  vertices = pokemon_network_2,
  directed = FALSE
)

# remove loops
pokemon_network <- igraph::simplify(pokemon_network, remove.multiple = FALSE, remove.loops = TRUE)

pokemon_network$layout <- igraph::layout_with_kk(pokemon_network)
rownames(pokemon_network$layout) <- V(pokemon_network)$name
colnames(pokemon_network$layout) <- c("x", "y")

pokemon_manual <- fromJSON("dev/pokemon_network_manual_layout.cyjs")
pokemon_manual <- pokemon_manual$elements$nodes
rownames(pokemon_manual$position) <- pokemon_manual$data$name
pokemon_manual <- pokemon_manual$position

# normalize on the range [-5,5]
pokemon_manual <- pokemon_manual %>%
  mutate(
    x = scales::rescale(x, to = c(-5, 5)),
    y = scales::rescale(y, to = c(-5, 5))
  )

# reorder by rowname to match pokemon_network$layout
pokemon_manual <- pokemon_manual[rownames(pokemon_network$layout), ]

# Pass the layout coordinates back to the original graph
pokemon_network$layout <- as.matrix(pokemon_manual)

use_data(pokemon_network, overwrite = TRUE)
```
